# 5

Направете сравнение между IEnumerable и IEnumerator, като поставите липсващите думи в текста:
IEnumerable се използва за [generic интерфейс], но IEnumerator се използва за [non‑generic интерфейс].
IEnumerable има [само един метод], докато IEnumerator има [само два метода].
IEnumerable [може да върне IEnumeratoко потребителя въведе числото 2147483648 програмата ще хвърли изключение от типа System.OverflowException със следното съобщение за грешка: Value was either too large or too small for an Int32. Това се получава така, защото липсва catch клауза за прихващане на изключение от този тип.

Посочете, кое от дадените твърдения е вярно за потоците в C#. Трябва да изберете вярно или невярно от падащото меню срещу всяко твърдение.

Потоците се използват, когато програмата трябва да прочете или запише данни от или във външен източник на данни. [Вярно] Потокът е наредена последователност от байтове. [Вярно] Тези байтове се изпращат един след друг и могат да се получават в ред различен от този в който са били изпратени. [Невярно] Потоците осигуряват последователен достъп до своите елементи. [Вярно] Потоците трябва да се отворят преди употреба и да се затворят накрая. [Вярно] Можем да манипулираме подредбата на данните в потока. [Невярно]

Дефинирайте какво представляват Lambda изразите и какъв е техният синтаксис, като попълните липсващите думи в текста.

Ламбда изразите представляват [анонимни функции], които съдържат изрази или последователност от оператори. Всички ламбда изрази използват ламбда оператора [=>], който може да се чете като "отива в". Лявата страна на ламбда оператора определя [входните параметри], а дясната страна представлява [израз или последователност от оператори], която работи с [входните параметри] на [анонимната функция] и евентуално връща някакъв резултат. Ламбда синтаксис: [(параметри) => {тяло}]

Решете правилно задачата. Имате дадени парчета от код, поставете отделните парчета така, че да получите правилно работещ код, който трябва да прочете данните от един файл и да ги копира в друг.

[using (var reader = new StreamReader("../../../Program.cs")) {]

[using (var writer = new StreamWriter("../../../Copy.cs")) {]

[string line = reader.ReadLine();]

[while (line != null) {]

[writer.WriteLine(line);]

[line = reader.ReadLine();]

[} } }]r]. IEnumerator [не може да върне IEnumerable]


Имате даден следния програмен фрагмент:

    int[] nums = { 1, 2, 3, 4, 5, 6};
    int count = nums[.Count(num => num % 2 == 0);]
Коя от следните LINQ заявки и какъв ламбда израз ще използвате, за да намерите броя на четните числа в колекцията?


Имате даден следния програмен фрагмент:

    int[] nums = { 1, 2, 2, 3, 4, 5, 6, -2, 2, 0, 15, 3, 1, 0, 6 };
    nums = nums[.Distinct()].ToArray();
Коя от следните LINQ заявки ще използвате, за да филтрирате колекцията, така че тя да съдържа само уникални елементи?


Посочете какво представлява и какво прави Current() от интерфейса IEnumerator:
Правилният отговор е: Current е свойството, което връща елемента от колекцията, който е на текущата позиция на итератора.


Имате даден следния програмен фрагмент:

        int[] nums = { 1, 2, 3, 4, 5, 6 };
        nums = nums[.Where(num => num % 2 == 0)].ToArray();
Коя от следните LINQ заявки и какъв ламбда израз ще използвате, за да филтрирате колекцията, така че тя да съдържа само четни числа?


Имате даден следния програмен фрагмент:

        int[] nums = { 11, 99, 33, 55, 77, 44, 66, 22, 88 };
        nums = nums[.OrderBy(x => x)].ToArray();
Коя от следните LINQ заявки ще използвате, за да подредите числата в колекцията във възходящ ред?
Обяснете следния фрагмент от код с думи:

int[] nums = { 1, 2, 3, 4, 5, 6 };
int[] otherNums = { 7, 8, 9, 0 };
nums = nums.Concat(otherNums);
Console.WriteLine(string.Join(", ", nums));
В полето запишете ред по ред какво прави кода и какво се очаква да получим като резултат.


Забележка
Инициализираме масив от цели числа nums и друг масив от цели числа otherNums.
Конкатенираме (или слепваме) двата масива - масив otherNums се "залепя" след масива nums.
Отпечатваме на конзолата елементите от масива на един ред разделени със ", ". 
Очакван резултат:
1, 2, 3, 4, 5, 6, 7, 8, 9, 0



Обяснете следния фрагмент от код с думи:

int[] nums = { 1, 2, 3, 4, 5, 6};
nums = nums.Reverse();
Console.WriteLine(string.Join(", ", nums));
В полето запишете ред по ред какво прави кода и какво се очаква да получим като резултат.


Забележка
Инициализираме масив от цели числа.
Обръщаме подредбата на числата (отзад-напред) с  (nums.Reverse) и запазваме новата подредба на масива nums.
Отпечатваме на конзолата елементите от масива на един ред разделени със ", ". 
Очакван резултат: 6, 5, 4, 3, 2, 1


Обяснете какво ще се случи и защо, ако потребителя въведе числото 2147483648: 
![image](https://github.com/arndv/5/assets/125039034/9df356e4-1751-4648-b06d-671251afdf7e)

Ако потребителя въведе числото 2147483648 програмата ще хвърли изключение от типа System.OverflowException със следното съобщение за грешка: Value was either too large or too small for an Int32. 
Това се получава така, защото липсва catch клауза за прихващане на изключение от този тип.


Посочете, кое от дадените твърдения е вярно за потоците в C#. Трябва да изберете вярно или невярно от падащото меню срещу всяко твърдение.

Потоците се използват, когато програмата трябва да прочете или запише данни от или във външен източник на данни. [Вярно]
Потокът е наредена последователност от байтове. [Вярно]
Тези байтове се изпращат един след друг и могат да се получават в ред различен от този в който са били изпратени. [Невярно]
Потоците осигуряват последователен достъп до своите елементи. [Вярно]
Потоците трябва да се отворят преди употреба и да се затворят накрая. [Вярно]
Можем да манипулираме подредбата на данните в потока. [Невярно]


Дефинирайте какво представляват Lambda изразите и какъв е техният синтаксис, като попълните липсващите думи в текста.

Ламбда изразите представляват [анонимни функции], които съдържат изрази или последователност от оператори. Всички ламбда изрази използват ламбда оператора [=>], който може да се чете като "отива в". Лявата страна на ламбда оператора определя [входните параметри], а дясната страна представлява [израз или последователност от оператори], която работи с [входните параметри] на [анонимната функция] и евентуално връща някакъв резултат.
Ламбда синтаксис: [(параметри) => {тяло}]


Решете правилно задачата. Имате дадени парчета от код, поставете отделните парчета така, че да получите правилно работещ код, който трябва да прочете данните от един файл и да ги копира в друг.

[using (var reader = new StreamReader("../../../Program.cs")) {]

[using (var writer = new StreamWriter("../../../Copy.cs")) {]

[string line = reader.ReadLine();]

[while (line != null) {]

[writer.WriteLine(line);]

[line = reader.ReadLine();]

[} } }]


![image](https://github.com/arndv/5/assets/125039034/669a3bbf-c21a-4164-a863-f1804d83f91d)


Напишете програма на C#, която да дефинира делегат, който може да приема анонимна функция, която умножава две цели числа. Накрая резултатът да се отпечата на конзолата.


    public delegate int Delegate(int firstNumber, int secondNumber);

    class Program
    {
        static void Main(string[] args)
        {
            Delegate del = new Delegate((x, y) => x *  y);
            Console.WriteLine(del(2, 3));
        }
    }
    
    
На конзолата ще ви бъдат подадени цели числа записани на един ред и разделени с интервал. Например: 5 7 12 56 24 3 8 
Напишете собствена функция на C# за парсване на цели числа. Запишете числата в подходяща структура от данни, след което отпечатайте числата на конзолата на един ред разделени със запетая и интервал.

      string input = Console.ReadLine();
      Func<string, int> parser = (x) => int.Parse(x);
      int[] nums = input.Split().Select(parser).ToArray();
      Console.WriteLine(string.Join(", ", nums));  
      
      
  //// CREATE LIST
  
            public List<T> CreateList<T>(T item, int count)//2т
        {
            List<T> list = new List<T>();//2т
            for (int i = 0; i < count; i++)
            {
                list.Add(item);
            }
            return list;//2т
        }
        
        
  ![image](https://github.com/arndv/5/assets/125039034/9f9e530e-61c1-4a2e-8353-5f876a795635)
  На конзолата ще се отпечатат всички четни числа. 2 4 6      

![image](https://github.com/arndv/5/assets/125039034/288c3e85-0482-4114-aa62-d0e1d2260a28)

      List<int> list = Console.ReadLine()
                .Split(", ", StringSplitOptions.RemoveEmptyEntries)
                .Select(int.Parse)
                .Where(x => x % 2 != 0)
                .OrderBy(x => x)
                .ToList();

            Console.WriteLine(string.Join(", ", list));
            
 
Посочете кое от изброените твърдения е вярно за работата на изключенията в C#.

Правилният отговор е: Ако по време на изпълнението на програмата някой от извикваните методи неочаквано хвърли изключение, то нормалният ход на програмата се преустановява. 



Модифицирайте кода,така че Везната да може да сравнява всякакви типове данни. Също така трябва да ограничите Везната, че елементите, които ще  сравнява ще бъдат само сравними типове. 


public class Scale<T> where T : IComparable<T>
    {
        private T left; 
        private T right; 

        public Scale(T left, T right)
        {
            this.left = left;
            this.right = right;
        }
        public T GetHavier()
        {
            if (left.CompareTo(right) > 0)
            { return left; }
            else if (left.CompareTo(right) < 0)
            { return right; }
            return default(T);
        }
    }

                                               
Hаправете сравнение между двата интерфейса IComparable и IComparer, като изберете липсващите думи в текста:

Интерфейсът IComparable<T> казва [„Аз съм нещо сравнимо“] и [дава метод за сравняване на два обекта].
Интерфейсът IComparer<T> казва [„Аз мога да сравнявам“] и [предоставя начин за промяна на реда на сортиране на колекция].              
  
    
    
На конзолата ще ви бъдат подадени реални числа записани на един ред и разделени с интервал. Например: 5.12 7.17 1.2 5.16 24.1 3 8 
Напишете собствена функция на C# за парсване на реални числа. Запишете числата в подходяща структура от данни, след което отпечатайте числата на конзолата на един ред разделени със запетая и интервал.


                    string input = Console.ReadLine();
                    Func<string, double> parser = (x) => double.Parse(x);
                    double[] nums = input.Split().Select(parser).ToArray();
                    Console.WriteLine(string.Join(", ", nums));    
   
    
    
Обяснете следния фрагмент от код с думи:

              List<int> list = new List<int>() { 20, 15, 1, 5, 7, 18, 66 };

              list.OrderByDescending(x => x).Take(3);

              Console.WriteLine(string.Join(", ", list));

В полето запишете ред по ред какво прави кода и какво се очаква да получим като резултат.

Забележка
Инициализираме списък с цели числа.
Сортираме числата от колекцията в низходящ ред и вземаме първите три числа от тях.
Очакван резултат: 20, 15, 1, 5, 7, 18, 66
Списъкът с числа си остава същия, защото OrderByDescending връща нов IOrderedEnumerable списък, а в дадения код не се презаписва новата подредба на числата върху предишния списък с числа.    

 //123   
![image](https://github.com/arndv/5/assets/125039034/77074a7e-7b5f-4004-8013-a81b8be42c38)
Ако потребителя въведе цяло число, това число ще се отпечата на конзолата и изпълнението на програмата се прекратява. 
Когато потребителя въведе вход на конзолата различен от цяло число, програмата ще прихване изключението FormatException и на конзолата ще се отпечата съобщение за грешка Input string was not in a correct format. Програмата се изпълнява докато потребителя въведе цяло число.     

    
![image](https://github.com/arndv/5/assets/125039034/7466bd52-48db-425b-a320-db21ca29c969)
 
    
Дефинирайте понятието функция, като попълните липсващите думи в текста.
Функцията е [специално отношение], където на [всички входни данни] има [еднозначен изход].


    
Дефинирайте IEnumerable. Какво представлява, какво съдържа и за какво се използва?
Основен интерфейс в .NET, позволяващ просто обхождане на колекция.
Съдържа един-единствен метод GetEnumerator(), който връща един IEnumerator<T>.
Клас, реализиращ IEnumerable<T> може да бъде използван за обхождане с цикъла foreach.

    
Имате следния примерен код:

    class Person
    {
        private int age;

        public int Age
        {
            get { return age; }
            private set 
            { 
                if(value < 0)
                {
                    [throw new ArgumentOutOfRangeException("Age must be positive number!");]
                }
                age = value;
            }
        }
    }

По какъв начин ще хвърлите изключение, че числото, което е въведено е невалидно?

                             
![image](https://github.com/arndv/5/assets/125039034/6be5e5d5-8f91-4cb0-a5be-85552c54a964)
